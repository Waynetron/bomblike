{"version":3,"sources":["containers.js","entity/Entity.js","map/constants.js","map/Map.js","math.js","map/map-util.js","entity/entity-util.js","Info.js","WinGraphic.js","entity/enemies.js","entity/behaviours.js","entity/weapons.js","entity/entities.js","map/map-generation.js","turn.js","input.js","App.js","index.js"],"names":["shake","css","grow","centered","AppContainer","styled","div","win","lose","getBackgroundColor","MapAndInfoContainer","props","undefined","MenuContainer","getColour","char","getBackgroundColour","getZIndex","solid","Container","attrs","x","y","style","left","top","zIndex","color","Inner","health","opacity","width","CELL_SIZE","height","backgroundColor","getBumpClass","status","attacking","getShakeClass","Cell","entity","hoverStart","position","className","onMouseEnter","getDisplayChar","MapContainer","Map","entities","hoverStop","MAP_WIDTH","MAP_HEIGHT","onMouseLeave","map","key","id","UP","DOWN","LEFT","RIGHT","add","a","b","subtract","turn","angle","direction","rotated","rotate","shuffle","original","shuffled","i","length","j","Math","floor","random","distanceBetween","x1","y1","x2","y2","sqrt","abs","getEntitiesAt","filter","isEqual","getEntitiesAtPositions","positions","flat","isAdjacentEdge","getAdjacentPositions","getPositionsInDirection","startPosition","distance","scaledDirection","offsetPosition","push","reverse","isCharInDirection","entitiesAtPosition","isWalkable","entitiesAtPostion","some","findPlayer","find","pickUpWeapon","player","weapon","remove","InfoBox","StatsContainer","Stats","stats","capacity","power","radius","timer","canRemoteDetonate","capacityText","getCapacityText","powerText","getPowerText","radiusText","getRadiusText","timerText","text","getTimerText","Info","hovered","events","entitiesAtPlayer","stairs","type","killer","playerKiller","name","description","getInfoToDisplay","HugeText","p","WinGraphic","wanderer","makeEntity","behaviours","walkInALine","faceWalkable","attackPlayer","charger","facing","pursuePlayerInLineOfSight","eater","eatBomb","pursueBombInLineOfSight","seeker","speed","pursuePlayer","ghostSpawner","spawnGhostOnDeath","visible","getRandomEnemy","level","available","isAttackable","containsAttackable","explodeOnDeath","attackPositions","spawnPositions","firstSolidIndex","findIndex","slice","attackActions","value","target","cost","spawnActions","flame","pursuePlayerThroughWalls","attackSelf","force","closestDirection","bestDistance","adjacent","bomb","makeBombBag","bagProps","bombProps","extraBagProps","use","bombsOut","owner","detonateActions","regularBombBehaviour","starterBombBag","ceil","weapons","largeRadius","veryLargeRadius","shortFuse","longFuse","noFuse","remoteDetonator","possibleBagTraitCombinations","traits","pop","trait","_id","console","error","alive","actions","actionsPerTurn","trail","wall","breakable","excludeClosest","sort","generateLevel","emptyEntities","isAdjacentPlayer","adjPosition","unbreakableWall","emptyEntity","shuffledEmptyEntities","maxThings","numBreakableWalls","min","remainingRandomSpots","numHoles","makeRoomWithPlayerAndWalls","shuffledFurthestEmpties","numEnemies","enemy","spawner","walls","shuffledFurthestWalls","staircaseDown","upOrDown","staircase","weaponFactory","totalTurns","move","newPosition","upcomingEntities","upcoming","placeBomb","newBomb","performActions","newEvents","action","actionPoints","armour","defense","performTurn","prevPosition","behaviour","processInput","input","newActions","findWeaponAt","App","useState","setLevel","setEntities","setEvents","setHovered","startGame","backToTitle","useCallback","nextLevel","handleKeyDown","event","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","keyToDirection","toLowerCase","getInput","preventDefault","Boolean","canEnterStairs","inputActions","everythingElse","remainingEntities","newEntities","performTurns","useEffect","window","addEventListener","removeEventListener","onClick","e","hoverEnd","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.34ef8280.chunk.js","sourcesContent":["import styled, { css } from 'styled-components'\n\nconst shake = css`\n  @keyframes shake {\n    20% {\n      transform: translate3d(4px, -4px, 0);\n    }\n    40% {\n      transform: translate3d(-4px, 4px, 0);\n    }\n    60% {\n      transform: translate3d(4px, 4px, 0);\n    }\n    80% {\n      transform: translate3d(-4px, -4px, 0);\n    }\n  }\n\n  animation-duration: 0.2s;\n  animation-fill-mode: forwards;\n  animation-timing-function: cubic-bezier(.36,.07,.19,.97);\n`\n\nconst grow = css`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  animation-name: grow;\n  animation-duration: 0.2s;\n  animation-fill-mode: forwards;\n`\n\nconst centered = css`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n`\n\nconst getBackgroundColor = (win, lose) => {\n  if (win) {\n    return 'black';\n  }\n  if (lose) {\n    return '#d42a2a';\n  }\n\n  return 'black';\n}\n\nexport const AppContainer = styled.div`\n  ${centered}\n  background-color: ${({win, lose}) => getBackgroundColor(win, lose)};\n  transition: background-color 0.2s cubic-bezier(0,1.56,.52,.99);\n  display: flex;\n  width: 100%;\n  height: 100%;\n`;\n\nexport const MapAndInfoContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n\n  ${shake}\n  ${grow}\n  animation-name: ${props => props.shake ? 'shake, grow' : undefined};\n`;\n\nexport const MenuContainer = styled.div`\n  ${centered}\n  animation-name: 'shake';\n  flex-direction: column;\n`;\n","import React from 'react';\nimport { CELL_SIZE } from '../map/constants';\nimport styled from 'styled-components'\nimport './Entity.css';\n\nconst getColour = (char) => {\n  const mapping = {\n    '@': '#fffa03',\n    '#': 'black',\n    '+': 'beige',\n    '>': '#fffa03',\n    '*': '#fffa03',\n    'b': '#fffa03',\n    'ó': '#fffa03',\n    '⍚': '#fffa03',\n    '!': 'white',\n    '❒': 'white',\n    '♥': '#fffa03',\n    '·': 'tomato'\n  }\n  \n  return mapping[char] || 'tomato';\n}\n\nconst getBackgroundColour = (char) => {\n  const mapping = {\n    '#': 'beige',\n    '+': '#4135ff',\n    '!': 'tomato',\n    '❒': 'black',\n  }\n  return mapping[char] || 'transparent'\n}\n\nconst getZIndex = (solid, char) => {\n  if (char === '·') {\n    return 0;\n  }\n  if (char === '❒') {\n    return 1;\n  }\n  if (char === '!') {\n    return 4;\n  }\n  if (char === 'b') {\n    return 3;\n  }\n  \n  if (solid) {\n    return 2;\n  }\n  \n  return 1;\n}\n\nconst Container = styled.div.attrs(({ x, y, solid, char }) => ({\n  style: {\n    left: x * CELL_SIZE + 'px',\n    top: y * CELL_SIZE + 'px',\n    zIndex: getZIndex(solid, char),\n    color: getColour(char),\n  }\n}))`\n  position: relative;\n  width: 0;\n  height: 0;\n`;\n\nconst Inner = styled.div.attrs(({ char, health }) => ({\n  style: {\n    opacity: char !== '·' ? '1' : `${20 * health / 100}`,\n    width: CELL_SIZE + 'px',\n    height: CELL_SIZE + 'px',\n    backgroundColor: getBackgroundColour(char),\n  }\n}))`\n  width: CELL_SIZE;\n  height: CELL_SIZE;\n  box-sizing: border-box;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  &:hover {\n    border: solid 2px white;\n    cursor: pointer;\n    p {\n      color: white;\n    }\n    background-color: navy;\n    opacity: 1;\n  }\n\n  p {\n    display: inline;\n    margin-block-start: ${props => props.char === '*' ? '1.5' : '0.2'}rem;\n    font-size: ${props => props.char === '*' ? '3rem' : 'inherit'};\n    margin-block-end: 0;\n    font-weight: 700;\n\n  }\n`;\n\nconst getBumpClass = (status)=> {\n  if (status.attacking) {\n    const {x, y} = status.attacking;\n    if (x < 0) {\n      return 'bump-left'\n    }\n    if (x > 0) {\n      return 'bump-right'\n    }\n    if (y < 0) {\n      return 'bump-up'\n    }\n    if (y > 0) {\n      return 'bump-down'\n    }\n  }\n\n  return '';\n}\n\nconst getShakeClass = (char, health)=> {\n  if (char === 'b' && health === 1) {\n    return 'shake';\n  }\n\n  return '';\n}\n\nconst getDisplayChar = (char, health) => {\n\n  if (char === '+') {\n    return '#';\n  }\n\n  if (char === '#') {\n    return '#';\n  }\n\n  if (char === 'b') {\n    if (health > 9) {\n      return '!'\n    }\n    \n    return health;\n  }\n\n  if (char === '❒') {\n    return '';\n  }\n\n  return char;\n}\n\nconst Cell = ({entity, hoverStart = ()=>{}}) => {\n  const {char, position: {x, y}, solid, status, health} = entity;\n  return (\n    <Container x={x} y={y} solid={solid} char={char}>\n      <Inner\n        char={char}\n        health={entity.health}\n        className={`${getBumpClass(status)} ${getShakeClass(char, health)}`}\n        onMouseEnter={() => hoverStart(entity)}\n      >\n        <p>{getDisplayChar(char, health)}</p>\n      </Inner>\n    </Container>\n  )\n}\n\nexport default Cell;","export const CELL_SIZE = 30;\nexport const MAP_WIDTH = 9;\nexport const MAP_HEIGHT = 9;","import React from 'react';\nimport styled from 'styled-components'\nimport Entity from '../entity/Entity';\nimport { CELL_SIZE, MAP_WIDTH, MAP_HEIGHT } from './constants';\n\nconst MapContainer = styled.div`\n  width: ${props => props.width}px;\n  height: ${props => props.height}px;\n  font-size: ${CELL_SIZE / 16}rem;\n  margin-bottom: 1rem;\n`\n\nconst Map = ({entities, hoverStart, hoverStop}) => {\n  return (\n    <MapContainer\n      width={MAP_WIDTH * CELL_SIZE}\n      height={MAP_HEIGHT * CELL_SIZE}\n      onMouseLeave={hoverStop}\n    >\n      {entities.map(entity =>\n        <Entity\n          entity={entity}\n          key={entity.id}\n          hoverStart={hoverStart}\n        />\n      )}\n    </MapContainer>\n  )\n}\n\nexport default Map;","import { rotate } from 'vector-math-fp';\n\nexport const [UP, DOWN, LEFT, RIGHT] = [{x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0}]\nexport const add = (a, b) => ({x: a.x + b.x, y: a.y + b.y});\nexport const subtract = (a, b) => ({x: a.x - b.x, y: a.y - b.y});\n\nexport const turn = (angle, direction) => {\n  const {x, y} = direction;\n  const rotated = rotate(angle, [x, y]);\n  const [rx, ry] = rotated;\n  return {x: rx, y: ry};\n}\n\nexport const shuffle = (original) => {\n  const shuffled = [...original];\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n  }\n  return shuffled;\n}\n\nexport const distanceBetween = ({x: x1, y: y1}, {x: x2, y: y2}) => {\n  return Math.sqrt(Math.abs(x1 - x2) ** 2 + Math.abs(y1 - y2) ** 2);\n}","import { MAP_WIDTH, MAP_HEIGHT } from './constants';\nimport { UP, DOWN, LEFT, RIGHT, add } from '../math';\nimport { isEqual } from 'lodash';\n\nexport const getEntitiesAt = (position, entities) =>\n  entities.filter(entity => isEqual(entity.position, position));\n\nexport const getEntitiesAtPositions = (positions, entities) => (\n  positions.map(position => getEntitiesAt(position, entities)).flat()\n);\n\nexport const isAdjacentEdge = ({x, y}) =>\n  x === 0 || x === MAP_WIDTH - 1 || y === 0 || y === MAP_HEIGHT - 1;\n\nexport const getAdjacentPositions = (position) => [\n  add(UP, position), add(DOWN, position), add(LEFT, position), add(RIGHT, position)\n];\n\nexport const getPositionsInDirection = (direction, startPosition, distance) => {\n  const positions = [];\n  while (distance > 0) {\n    const scaledDirection = {x: direction.x * distance, y: direction.y * distance};\n    const offsetPosition = add(startPosition, scaledDirection);\n    positions.push(offsetPosition);\n    distance -= 1;\n  }\n  return positions.reverse();\n};\n\nexport const isCharInDirection = (char, direction, startPosition, distance, entities) => {\n  const positions = getPositionsInDirection(direction, startPosition, distance);\n  for (const position of positions) {\n    const entitiesAtPosition = getEntitiesAt(position, entities);\n    for (const entity of entitiesAtPosition) {\n      if (entity.char === char) {\n        return true;\n      }\n      else if (entity.solid) {\n        return false;\n      }\n    }\n  }\n  return false;\n};\n\nexport const isWalkable = (position, entities) => {\n  const entitiesAtPostion = getEntitiesAt(position, entities);\n\n  // nothing there at all\n  if (entitiesAtPostion.length === 0) {\n    return true;\n  }\n\n  // something solid there\n  if (entitiesAtPostion.some(entity => entity.solid)) {\n    return false;\n  }\n\n  // something there, but it can be walked over\n  return true;\n}","import { getEntitiesAt } from '../map/map-util';\nimport { remove } from 'lodash';\n\nexport const findPlayer = entities => entities.find(entity => entity.char === '@');\n\nexport const canEnterStairs = (player, entities) => {\n  const collidingEntities = getEntitiesAt(player.position, entities);  \n  const stairs = collidingEntities.find(entity => entity.char === '>');\n\n  return Boolean(stairs);\n}\n\nexport const findWeaponAt = (position, entities) => {\n  const collidingEntities = getEntitiesAt(position, entities);  \n  return collidingEntities.find(entity => entity.type === 'weapon');\n}\n\nexport const pickUpWeapon = (player, weapon, entities) => {      \n    player.weapon = weapon;\n    remove(entities, entity => entity.id === weapon.id);\n}","import React from 'react';\nimport styled from 'styled-components'\nimport { findPlayer } from './entity/entity-util';\nimport { CELL_SIZE, MAP_WIDTH } from './map/constants';\nimport { getEntitiesAt } from './map/map-util';\n\nconst InfoBox = styled.div`\n  justify-content: start;\n  align-content: center;\n  flex-direction: column;\n  display: flex;\n  width: ${props => props.width}px;\n  min-height: 7rem;\n  \n  p {\n    text-align: center;\n    line-height: 1.5rem;\n    font-size: 1.2rem;\n    color: white;\n    font-weight: 400;\n    margin-top: 0.6rem;\n    margin-bottom: 0.5rem;\n  }\n  .key {\n    color: #fffa03;\n    font-weight: 600;\n  }\n`\n\nconst StatsContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  span {\n    display: inline-block;\n  }\n  .trait {\n    color: #fffa03;\n    font-weight: 600;\n  }\n  .rare {\n    color: tomato;\n  }\n`\n\nconst getCapacityText = (capacity)=> {\n  const options = ['', 'large', 'plentiful'];\n  return options[capacity - 1];\n}\n\nconst getPowerText = (power)=> {\n  const options = [null, 'powerful', 'very powerful', 'dangerously powerful']\n  return options[power - 1];\n}\n\nconst getRadiusText = (radius)=> {\n  const options = [null, 'large radius', 'very large radius', 'dangerously large radius'];\n  return options[radius - 1];\n}\n\nconst getTimerText = (timer)=> {\n  let text = null;\n  if (timer === 2) {\n    text = 'short fuse'\n  }\n  if (timer === 5) {\n    text = 'long fuse'\n  }\n  return text;\n}\n\nconst Stats = ({entity}) => {\n  if (!entity || !entity.stats) {\n    // returning empty stats container to prevent the height from shifting\n    return <StatsContainer><p></p></StatsContainer>;\n  }\n\n  const { capacity, power, radius, timer, canRemoteDetonate } = entity.stats;\n\n  const capacityText = getCapacityText(capacity);\n  const powerText = getPowerText(power);\n  const radiusText = getRadiusText(radius);\n  const timerText = getTimerText(timer);\n\n  return (\n  <StatsContainer>\n    <p>\n      <span>A</span>\n      { \" \" }\n      {capacityText && <span className=\"trait\">{capacityText} </span>}\n      { \" \" }\n      <span>bomb bag</span>\n      { \" \" }\n      {(powerText || radiusText || timerText || canRemoteDetonate) && <span>with</span>}\n      { \" \" }\n      {powerText && <span className=\"trait\">{powerText} </span>}\n      { \" \" }\n      {radiusText && <span className=\"trait\">{radiusText} </span>}\n      { \" \" }\n      {timerText && <span className=\"trait\">{timerText} </span>}\n      { \" \" }\n      {canRemoteDetonate && <span className=\"trait rare\">remote control</span>}\n      { \" \" }\n      {(powerText || radiusText || timerText || canRemoteDetonate) && <span>bombs</span>}\n    </p>\n  </StatsContainer>\n  );\n}\n\nconst getInfoToDisplay = (hovered, entities, win, lose, events) => {\n  const player = findPlayer(entities);\n  const entitiesAtPlayer = player ? getEntitiesAt(player.position, entities) : [];\n  const stairs = entitiesAtPlayer.find(entity => entity.char === '>');\n  const weapon = entitiesAtPlayer.find(entity => entity.type === 'weapon');\n\n  if (!weapon && !stairs && !hovered && !win && !lose) {\n    return null;\n  }\n\n  const entity = weapon || stairs || hovered;\n\n  if (lose) {\n    const killer = events.playerKiller;\n    return (\n      <>\n        <p>You were killed by a <span className=\"key\">{killer ? killer.name : 'something'}</span></p>\n        <p>Back to title <span className=\"key\">(x)</span></p>\n      </>\n    );\n  }\n\n  if (win) {\n    return (\n      <>\n        <p>You conquered the dungeon. Way to go!</p>\n        <p>Back to title <span className=\"key\">(x)</span></p>\n      </>\n    );\n  }\n\n  // Player sitting over weapon\n  if (weapon) {\n    return (\n      <>\n        <Stats entity={entity} />\n        <p>take <span className=\"key\">(x)</span></p>\n      </>\n    );\n  }\n  // Player sitting over stairs\n  else if (stairs) {\n    return (\n      <>\n        <p>{entity.description || ''}</p>\n        <p>descend <span className=\"key\">(x)</span></p>\n      </>\n    );\n  }\n  // Hovering something with the mouse\n  else {\n    return (\n      <>\n        {hovered.stats\n          ? <Stats entity={hovered} />\n          : <p>{hovered.description || ''}</p>}\n      </>\n    );\n  }\n}\n\nconst Info = ({hovered, entities, win, lose, events}) => {\n  return (\n    <InfoBox width={MAP_WIDTH * CELL_SIZE}>\n      {getInfoToDisplay(hovered, entities, win, lose, events)}\n    </InfoBox>\n  )\n}\n\nexport default Info;","import React from 'react';\nimport styled from 'styled-components'\n\nconst HugeText = styled.p`\n  font-size: 15rem;\n  color: beige;\n  font-weight: 700;\n  margin-top: 0;\n  margin-bottom: 3rem;\n  \n  .player {\n    color: #fffa03;\n  }\n`\n\nconst WinGraphic = () => {\n  return <HugeText>\n    <span className=\"player\">@</span>!\n  </HugeText>\n}\n\nexport default WinGraphic;","import { walkInALine, faceWalkable, attackPlayer, pursuePlayerInLineOfSight,\n  pursueBombInLineOfSight, eatBomb, pursuePlayerThroughWalls, pursuePlayer, turnLeft, turnRight,\n  spawnGhostOnDeath } from './behaviours';\nimport { makeEntity } from './entities';\n\nexport const wanderer = (props) => {\n  return makeEntity({\n    char: 'W',\n    solid: true,\n    behaviours: [walkInALine, faceWalkable, attackPlayer],\n    name: 'wanderer',\n    description: \"Moves until it hits something, then turns.\",\n    ...props,\n  })\n};\n\nexport const leftie = (props) => {\n  return makeEntity({\n    char: 'L',\n    solid: true,\n    behaviours: [walkInALine, turnLeft, attackPlayer],\n    name: 'leftie',\n    description: \"It's not an ambi-turner\",\n    ...props,\n  })\n};\n\nexport const rightie = (props) => {\n  return makeEntity({\n    char: 'L',\n    solid: true,\n    behaviours: [walkInALine, turnRight, attackPlayer],\n    name: 'leftie',\n    description: \"It's not an ambi-turner\",\n    ...props,\n  })\n};\n\nexport const charger = (props) => {\n  return makeEntity({\n    char: 'C',\n    solid: true,\n    facing: {x: 0, y: 0},\n    behaviours: [pursuePlayerInLineOfSight, walkInALine, attackPlayer],\n    name: 'charger',\n    description: 'If it sees you, it charges toward you',\n    ...props,\n  })\n};\n\nexport const eater = (props) => {\n  return makeEntity({\n    char: 'E',\n    solid: true,\n    behaviours: [eatBomb, pursueBombInLineOfSight, attackPlayer],\n    name: 'bombeater',\n    description: 'Eats bombs, om nom',\n    ...props,\n  })\n};\n\nexport const spooky = (props) => {\n  return makeEntity({\n    char: '!',\n    solid: false,\n    health: 99,\n    speed: 'half',\n    behaviours: [pursuePlayerThroughWalls, attackPlayer],\n    name: 'time cop',\n    description: \"Oh no, it's the fun police!\",\n    ...props,\n  })\n};\n\nexport const seeker = (props) => {\n  return makeEntity({\n    char: 'S',\n    solid: true,\n    health: 1,\n    speed: 'half',\n    behaviours: [pursuePlayer, attackPlayer],\n    name: 'seeker',\n    description: 'It just wants to be close to you',\n    ...props,\n  })\n};\n\nexport const ghostSpawner = (props) => {\n  return makeEntity({\n    char: 's',\n    solid: false,\n    health: 5,\n    behaviours: [spawnGhostOnDeath],\n    name: 'ghost spawner',\n    description: '',\n    visible: false,\n    ...props,\n  })\n};\n\nexport const getRandomEnemy = (level, props) => {\n  const levels = [\n    [wanderer],\n    [wanderer, charger],\n    [wanderer, charger, seeker, eater],\n    [wanderer, charger, seeker, eater],\n    [wanderer, charger, seeker, eater],\n  ];\n\n  const available = levels[level - 1];\n  const index = Math.floor(Math.random() * available.length);\n  return available[index](props);\n}","/*\nBehaviours are used at the start of a turn to generate a set of actions\n*/\n\nimport { getEntitiesAt, getEntitiesAtPositions, getAdjacentPositions,\n  isWalkable, getPositionsInDirection, isCharInDirection } from '../map/map-util';\nimport { flame } from './entities';\nimport { findPlayer } from './entity-util';\nimport { spooky } from './enemies';\nimport { UP, DOWN, LEFT, RIGHT, add, subtract, turn, distanceBetween } from '../math';\nimport { remove } from 'lodash';\n\nconst isAttackable = (entity) => {\n  if (entity.char === '❒') {\n    return false;\n  }\n  if (entity.solid || entity.char === '@') {\n    return true;\n  }\n  \n  return false;\n}\n\nconst containsAttackable = (position, entities) => {\n  return getEntitiesAt(position, entities).find(isAttackable)\n}\n\nexport const explodeOnDeath = (entity, entities) => {\n  const {radius, power} = entity;\n  entity.health -= 1;\n  if (entity.health > 0) {\n    return [];\n  } else {\n    const attackPositions = [entity.position];\n    const spawnPositions = [entity.position];\n\n    for (const direction of [UP, DOWN, LEFT, RIGHT]) {\n      const positions = getPositionsInDirection(direction, entity.position, radius, entities)\n      const firstSolidIndex = positions.findIndex(position => containsAttackable(position, entities));\n      if (firstSolidIndex !== -1) {\n        attackPositions.push(positions[firstSolidIndex]);\n        spawnPositions.push(...positions.slice(0, firstSolidIndex + 1));\n      }\n      else {\n        spawnPositions.push(...positions);\n      }\n    }\n\n    const entitiesToAttack = getEntitiesAtPositions(attackPositions, entities);\n\n    const attackActions = entitiesToAttack.map(entity => (\n      {type: 'attack', value: power, target: entity, cost: 0}\n    ));\n\n    // Spawn fire\n    const spawnActions = spawnPositions.map(position => (\n      {type: 'spawn', value: 1, entity: flame({position}), cost: 0}\n    ));\n    return [...attackActions, ...spawnActions];\n  }\n}\n\nexport const spawnGhostOnDeath = (entity, entities) => {\n  entity.health -= 1;\n  if (entity.health > 0) {\n    return [];\n  } else {\n    const { position } = entity;\n    return [{type: 'spawn', value: 1, entity: spooky({position}), cost: 0}]    \n  }\n}\n\nexport const attackSelf = (entity, entities) => {\n  return [{type: 'attack', value: 1, target: entity, cost: 0}]\n}\n\nexport const walkInALine = (entity, entities) => {\n  const { facing } = entity;\n  return [{type: 'move', direction: facing, cost: 1}]\n}\n\nexport const pursuePlayerInLineOfSight = (entity, entities) => {\n  for (const direction of [UP, DOWN, LEFT, RIGHT]) {\n    const range = 12;\n    if (isCharInDirection('@', direction, entity.position, range, entities)) {\n      return [\n        {type: 'move', direction, cost: 1},\n        {type: 'face', direction, cost: 0}\n      ]\n    }\n\n  }\n  return [];\n}\n\nexport const pursueBombInLineOfSight = (entity, entities) => {\n  for (const direction of [UP, DOWN, LEFT, RIGHT]) {\n    const range = 12;\n    if (isCharInDirection('b', direction, entity.position, range, entities)) {\n      return [\n        {type: 'move', direction, cost: 1},\n        {type: 'face', direction, cost: 0}\n      ]\n    }\n\n  }\n  return [];\n}\n\nexport const pursuePlayerThroughWalls = (entity, entities) => {\n  const player = findPlayer(entities);\n  const x = player.position.x > entity.position.x ? 1 : -1;\n  const y = player.position.y > entity.position.y ? 1 : -1;\n\n  const direction = Math.random() > 0.5 ? {x: 0, y: y} : {x: x, y: 0};\n\n  return [{type: 'move', direction, cost: 1, force: true}];\n}\n\nexport const pursuePlayer = (entity, entities) => {\n  const player = findPlayer(entities);\n  \n  let closestDirection;\n  let bestDistance = distanceBetween(entity.position, player.position);\n\n  for (const direction of [UP, DOWN, LEFT, RIGHT]) {\n    const position = add(direction, entity.position);\n    const distance = distanceBetween(position, player.position)\n\n    if (isWalkable(position, entities) && distance < bestDistance) {\n      closestDirection = direction;\n      bestDistance = distance;\n    }\n  }\n\n  if (closestDirection) {\n    return [{type: 'move', direction: closestDirection, cost: 1}];\n  }\n\n  return [];\n}\n\nexport const faceWalkable = (entity, entities) => {\n  const { facing } = entity;\n\n  // The order is intentional. The forward (facing) direction is placed first, so that\n  // the entity will continue moving in that direction if it can.\n  // Turning around is placed at the end, so that turning left / right is favoured.\n  const directions = [facing, turn(-90, facing), turn(90, facing), turn(180, facing)];\n\n  for (const direction of directions) {\n    const position = add(direction, entity.position);\n    if (isWalkable(position, entities)) {\n      return [{type: 'face', direction, cost: 0}]\n    }\n  }\n\n  // Surrounded on all sides, do nothing\n  return [];\n}\n\nexport const turnLeft = (entity, entities) => {\n  const { facing } = entity;\n\n  // The order is intentional. The forward (facing) direction is placed first, so that\n  // the entity will continue moving in that direction if it can.\n  // Turning around is placed at the end, so that turning left / right is favoured.\n  const directions = [turn(-90, facing), turn(90, facing), facing, turn(180, facing)];\n\n  for (const direction of directions) {\n    const position = add(direction, entity.position);\n    if (isWalkable(position, entities)) {\n      return [{type: 'face', direction, cost: 0}]\n    }\n  }\n\n  // Surrounded on all sides, do nothing\n  return [];\n}\n\nexport const turnRight = (entity, entities) => {\n  const { facing } = entity;\n\n  // The order is intentional. The forward (facing) direction is placed first, so that\n  // the entity will continue moving in that direction if it can.\n  // Turning around is placed at the end, so that turning left / right is favoured.\n  const directions = [turn(90, facing), turn(-90, facing), facing, turn(180, facing)];\n\n  for (const direction of directions) {\n    const position = add(direction, entity.position);\n    if (isWalkable(position, entities)) {\n      return [{type: 'face', direction, cost: 0}]\n    }\n  }\n\n  // Surrounded on all sides, do nothing\n  return [];\n}\n\nexport const attackPlayer = (entity, entities) => {\n  const colliding = getEntitiesAt(entity.position, entities);\n  const player = colliding.find(entity => entity.char === '@');\n\n  if (player) {\n    return [\n      {type: 'attack', value: 1, target: player, cost: 0}\n    ];\n  }\n\n  return [];\n}\n\nexport const eatBomb = (entity, entities) => {\n  const adjacent = getAdjacentPositions(entity.position);\n  for (const position of adjacent) {\n    const adjacentEntities = getEntitiesAt(position, entities);\n    const bomb = adjacentEntities.find(entity => entity.char === 'b');\n    if (bomb) {\n      const direction = subtract(position, entity.position);\n      \n      return [\n        {type: 'eat', target: bomb, cost: 0},\n        {type: 'move', direction, cost: 1}\n      ];\n    }\n  }\n\n  return [];\n}\n\nexport const attackAdjacentPlayer = (entity, entities) => {\n  const adjacent = getAdjacentPositions(entity.position);\n  const adjacentEntities = getEntitiesAtPositions(adjacent, entities);\n  const player = adjacentEntities.find(entity => entity.char === '@');\n  if (player) {\n    return [{type: 'attack', value: 1, target: player, cost: 1}];\n  }\n\n  return [];\n}\n\nexport const attackAdjacentPlayerAndDie = (entity, entities) => {\n  const adjacent = getAdjacentPositions(entity.position);\n  const adjacentEntities = getEntitiesAtPositions(adjacent, entities);\n  const player = adjacentEntities.find(entity => entity.char === '@');\n  if (player) {\n    return [\n      {type: 'attack', value: 1, target: player, cost: 1},\n      {type: 'attack', value: 1, target: entity, cost: 1}\n    ];\n  }\n\n  return [];\n}\n\nexport const pickUpWeapons = (entity, entities) => {  \n  const collidingEntities = getEntitiesAt(entity.position, entities);  \n  const weapon = collidingEntities.find(entity => entity.type === 'weapon');\n  if (!weapon) {\n    return [];\n  }\n\n  // pick up the weapon\n  entity.weapon = weapon;\n  remove(entities, entity => entity.id === weapon.id);\n  \n  return [];\n}\n\nexport const pickUpArmour = (entity, entities) => {  \n  const collidingEntities = getEntitiesAt(entity.position, entities);  \n  const armour = collidingEntities.find(entity => entity.type === 'armour');\n  if (!armour) {\n    return [];\n  }\n\n  // pick up the armour\n  entity.armour = armour;\n  remove(entities, entity => entity.id === armour.id);\n  \n  return [];\n}\n\nexport const pickUpConsumables = (entity, entities) => {  \n  const collidingEntities = getEntitiesAt(entity.position, entities);  \n  const item = collidingEntities.find(entity => entity.type === 'consumable');\n  if (!item) {\n    return [];\n  }\n\n  // use it right away, then discard it\n  const action = item.use(entity);\n  remove(entities, entity => entity.id === item.id);\n  \n  return [action];\n}","import { makeEntity, bomb } from './entities';\nimport { shuffle } from '../math';\n\nconst regularBombBehaviour = (entity, entities, bombProps) => {\n  const bombsOut = entities.filter(entity => entity.char === 'b' && entity.owner.char === '@');\n      \n  if (bombsOut.length < entity.weapon.capacity) {\n    return [{\n      type: 'place-bomb',\n      cost: 1,\n      bomb: bomb({...bombProps, position: entity.position})\n    }]\n  }\n\n  // bomb can be remote detonated\n  if (bombProps.canRemoteDetonate) {\n    const detonateActions = bombsOut.map(bomb => ({\n      type: 'attack',\n      target: bomb,\n      value: bomb.health,\n      cost: 0,\n    }));\n  \n    return [...detonateActions, {type: 'wait', cost: 1}];\n  }\n\n  return [];\n}\n\nconst makeBombBag = (bagProps, bombProps, extraBagProps) => {\n  const weapon = makeEntity({\n    char: 'ó',\n    type: 'weapon',\n    solid: false,\n    health: 999,\n    capacity: bagProps.capacity || 1,\n    description: 'A standard bomb bag',\n    stats: {\n      radius: bombProps.radius,\n      power: bombProps.power,\n      capacity: bagProps.capacity,\n      // health displayed as timer to users\n      timer: bombProps.health,\n      // if bomb can be remote detonated\n      canRemoteDetonate: bombProps.canRemoteDetonate || false,\n    },\n    use: (entity, entities) => regularBombBehaviour(entity, entities, bombProps),\n    ...extraBagProps,\n  });\n\n  return weapon;\n}\n\n// health equates to the number of turns before a bomb explodes\n// capacity is how many bombs can be active at a time\n\nexport const proceduralBombBag = (level, props = {}) => {\n  const largeRadius = {radius: 2};\n  const veryLargeRadius = {radius: 3};\n  const shortFuse = {health: 2};\n  const longFuse = {health: 5};\n  const noFuse = {health: 999};\n  const remoteDetonator = {canRemoteDetonate: true};\n  \n  let bagProps = {};\n  let bombProps = {};\n\n  const possibleBagTraitCombinations = [\n    [veryLargeRadius, longFuse],\n    [shortFuse],\n    [largeRadius],\n    [shortFuse, largeRadius],\n    [veryLargeRadius],\n    [remoteDetonator, noFuse],\n    [remoteDetonator, noFuse, largeRadius],\n  ]\n  const traits = shuffle(possibleBagTraitCombinations).pop();\n  for (const trait of traits) {\n    bombProps = {...bombProps, ...trait}\n  }\n  \n  return makeBombBag(bagProps, bombProps, props);\n}\n\nexport const starterBombBag = (level, props = {}) => {\n  const bagProps = {\n    capacity: 1,\n    description: 'A starter bomb bag',\n  }\n  const bombProps = {\n    radius: Math.ceil(Math.random() * level),\n    health: 3,\n    power: 1,\n  };\n  return makeBombBag(bagProps, bombProps, props);\n}\n\nconst weapons = [proceduralBombBag];\n\nexport const getRandomWeapon = () => {\n  const shuffled = shuffle(weapons);\n  const weapon = shuffled[0];\n  \n  return weapon;\n}","import { explodeOnDeath, attackSelf } from '../entity/behaviours';\nimport { starterBombBag } from './weapons';\n\nlet _id = 0;\nconst makeId = ()=> _id++;\n\nexport const makeEntity = (props) => {\n  if (!props.position) console.error('entity was created without a position', props);\n  if (props.id) console.error('Entity should probably not have a custom ID');\n\n  return {\n    id: makeId(),\n    name: 'thing',\n    char: '?',\n    weapon: null,\n    facing: {x: 0, y: 1},\n    alive: true,\n    solid: false,\n    behaviours: [],\n    actions: [],\n    actionsPerTurn: 1,\n    status: {},\n    health: 1,\n    description: '',\n    visible: true,\n    ...props,\n  }\n};\n\nexport const empty = (props) => {\n  return makeEntity({\n    char: '·',\n    solid: false,\n    ...props,\n  });\n}\n\nexport const player = (props) => {\n  return makeEntity({\n    char: '@',\n    name: 'player',\n    solid: false,\n    health: 1,\n    behaviours: [],\n    description: \"It's you, the player\",\n    weapon: starterBombBag(1),\n    armour: null,\n    ...props,\n  })\n};\n\nexport const bomb = (props) => {\n  return makeEntity({\n    char: 'b',\n    name: 'bomb',\n    solid: true,\n    behaviours: [explodeOnDeath],\n    description: \"It's a bomb, and it's going to explode!\",\n    health: 3,\n    power: 1,\n    radius: 1,\n    ...props,\n  })\n};\n\nexport const hole = (props) => {\n  return makeEntity({\n    char: '❒',\n    name: 'hole',\n    solid: true,\n    description: \"A hole in the ground\",\n    health: 999,\n    ...props,\n  })\n};\n\nexport const flame = (props) => {\n  return makeEntity({\n    char: '*',\n    name: 'flame',\n    solid: false,\n    behaviours: [attackSelf],\n    health: 1,\n    ...props,\n  })\n};\n\nexport const trail = (props) => {\n  return makeEntity({\n    char: '·',\n    name: 'trail',\n    solid: false,\n    behaviours: [attackSelf],\n    health: 3,\n    ...props,\n  })\n};\n\nexport const staircase = (props, upOrDown = 'down') => {\n  return makeEntity({\n    char: upOrDown === 'down' ? '>' : '<',\n    name:'staircase',\n    health: 999,\n    description: \"You see a staircase leading down\",\n    ...props,\n  })\n};\n\nexport const wall = (props, breakable = true) => {\n  return makeEntity({\n    char: breakable ? '+' : '#',\n    name: 'breakable wall',\n    health: breakable ? 1 : 999,\n    solid: true,\n    description: `You see a wall. ${!breakable ? 'It seems unbreakable.' : ''}`,\n    ...props,\n  })\n};","import { MAP_WIDTH, MAP_HEIGHT } from './constants';\nimport { isAdjacentEdge, getAdjacentPositions } from '../map/map-util';\nimport { empty, staircase, wall, hole } from '../entity/entities';\nimport { getRandomEnemy, ghostSpawner } from '../entity/enemies';\nimport { getRandomWeapon } from '../entity/weapons';\nimport { shuffle, distanceBetween } from '../math';\nimport { isEqual } from 'lodash';\n\nexport const makeRoomWithPlayerAndWalls = (player) => {\n  const entities = [player];\n  const emptyEntities = [];\n\n  for (let x = 0; x < MAP_WIDTH; x += 1) {\n    for (let y = 0; y < MAP_HEIGHT; y += 1) {\n      const position = {x, y};\n      // don't place anything where the player is\n      if (isEqual(position, player.position)) {\n        continue;\n      }\n\n      const adjacentPositons = getAdjacentPositions(player.position);\n      const isAdjacentPlayer = adjacentPositons.find(adjPosition => isEqual(position, adjPosition));\n\n      if (isAdjacentEdge(position) || (x % 2 === 0 && y % 2 === 0)) {\n        const unbreakableWall = wall({position}, false);\n        entities.push(unbreakableWall);\n      }\n      // don't place breakable walls next to where the player is\n      else if (!isAdjacentPlayer) {\n        const emptyEntity = empty({position});\n        emptyEntities.push(emptyEntity);\n      }\n    }\n  }\n\n  let shuffledEmptyEntities = shuffle(emptyEntities);\n\n  // need to leave some spots for the player and enemies to fit and walk around\n  const maxThings = emptyEntities.length - 16;\n  // need to have at least enough breakable walls to hide items and stairs\n  const minBreakableWalls = 5;\n  const numBreakableWalls = Math.min(Math.random() * (maxThings / 4) + minBreakableWalls, maxThings);\n  const remainingRandomSpots = maxThings - numBreakableWalls;\n  const numHoles = Math.min(Math.random() * remainingRandomSpots / 2, 0);\n\n  for (let i = 0; i < numBreakableWalls; i += 1) {\n    const position = shuffledEmptyEntities.pop().position;\n     entities.push(wall({position}, true));\n  }\n\n  for (let i = 0; i < numHoles; i += 1) {\n    const position = shuffledEmptyEntities.pop().position;\n     entities.push(hole({position}));\n  }\n\n  return [...entities, ...shuffledEmptyEntities];\n}\n\n// removes entities that are too close to the player\nconst excludeClosest = (entities, player) => {  \n  entities.sort((a, b)=> {\n    const distanceA = distanceBetween(a.position, player.position);\n    const distanceB = distanceBetween(b.position, player.position);\n    return distanceA - distanceB;\n  })\n  return entities.slice(Math.floor(entities.length / 4));\n}\n\nexport const generateLevel = (level, player) => {\n  const entities = makeRoomWithPlayerAndWalls(player);\n\n  // Add enemies\n  const emptyEntities = entities.filter(entity => entity.char === '·');\n  let shuffledFurthestEmpties = shuffle(excludeClosest(emptyEntities, player));\n  const numEnemies = Math.ceil(level * 1.75);\n  for (let i = 0; i < numEnemies; i += 1) {\n    const emptyEntity = shuffledFurthestEmpties.pop();\n\n    const enemy = getRandomEnemy(level, {position: emptyEntity.position});\n    entities.push(enemy);\n  }\n\n  // Add ghost spawner (spawns a ghost if the player is taking too long)\n  const ghostsProps = [\n    {health: 75, position: {x: -2, y: -2}},\n    {health: 100, position: {x: MAP_WIDTH + 1, y: -2}},\n    {health: 125, position: {x: MAP_WIDTH + 1, y: MAP_HEIGHT + 1}},\n    {health: 150, position: {x: -2, y: MAP_HEIGHT + 1}},\n  ]\n  for (const props of ghostsProps) {\n    const spawner = ghostSpawner(props);\n    entities.push(spawner); \n  }\n\n  // Add staircase and weapons underneath breakable walls\n  const walls = entities.filter(entity => entity.char === '+');\n  const shuffledFurthestWalls = shuffle(excludeClosest(walls, player));\n\n  const staircaseDown = staircase({\n    position: shuffledFurthestWalls.pop().position\n  });\n  entities.push(staircaseDown);\n\n  const weaponFactory = getRandomWeapon();\n  const bagProps = {position: shuffledFurthestWalls.pop().position};\n  const weapon = weaponFactory(level + 1, bagProps);\n  entities.push(weapon);\n\n  // finally, remove all the empty entities\n  return entities.filter(entity => entity.char !== '·');\n}","import { trail } from './entity/entities';\nimport { findPlayer, pickUpWeapon } from './entity/entity-util';\nimport { getEntitiesAt } from './map/map-util';\nimport { subtract } from './math';\n\nlet totalTurns = 0;\n\nexport const move = (entity, entities, direction, force = false) => {\n  const newPosition = {\n    x: entity.position.x + direction.x,\n    y: entity.position.y + direction.y\n  }\n\n  // Check if anything is in the way (unless force is true)\n  const upcomingEntities = getEntitiesAt(newPosition, entities);\n  if (!force && upcomingEntities.filter(upcoming => upcoming.solid).length > 0) {\n    return false;\n  }\n\n  // Add a trail entity at he old position\n  entities.push(trail({position: entity.position}));\n\n  // Move the entity into the new position\n  entity.position = newPosition\n  return true;\n}\n\nconst placeBomb = (entity, entities, bomb) => {\n  const newBomb = {\n    ...bomb,\n    position: entity.position,\n    owner: entity,\n  }\n\n  entities.push(newBomb);\n}\n\n// **IMPORTANT** Perform actions does a lot of sneaky mutation\n// May mutate any entity (either the supplied entity, but also any entity referenced in an action)\n// May push events into newEvents\nconst performActions = (actions, entity, entities, newEvents) => {\n    const player = findPlayer(entities);\n\n    while(actions.length > 0) {\n      const action = actions.pop();\n\n      if (entity.actionPoints >= action.cost) {\n        entity.actionPoints -= action.cost\n      } else {\n        continue;\n      }\n\n      // similar to attack, but immediately sets target to !alive to avoid triggering explosions\n      if (action.type === 'eat') {\n        action.target.alive = false;\n        action.target.solid = false;\n        newEvents.shake = true;\n      }\n      if (action.type === 'attack') {\n        const { value, target } = action;\n        if (target.armour) {\n          target.armour.defense -= value;\n        }\n        else {\n          target.health -= value;\n        }\n        entity.status['attacking'] = subtract(target.position, entity.position);\n\n        // the trails die a little every turn, so we need to prevent them from triggering shakes\n        if (target.char !== '·') {\n          newEvents.shake = true;\n        }\n        \n        // we log the players killer as an event so that the info text can see who killed the player\n        if (target.id === player.id && player.health <= 0) {\n          newEvents.playerKiller = entity;\n        }\n      }\n      if (action.type === 'move') {\n        move(entity, entities, action.direction, action.force)\n      }\n      if (action.type === 'pick-up') {\n        // entity picks up target\n        const { entity, target } = action\n        pickUpWeapon(entity, target, entities);\n      }\n      if (action.type === 'spawn') {\n        const { entity } = action;\n        entities.push(entity);\n      }\n      if (action.type === 'place-bomb') {\n        placeBomb(entity, entities, action.bomb)\n      }\n      if (action.type === 'face') {\n        entity.facing = action.direction;\n      }\n    }\n}\n\nconst performTurn = (entity, entities, newEvents) => {\n  // entities with speed 'half' only perform every 2nd turn\n  if (entity.speed === 'half' && totalTurns % 2 === 0) {\n    return\n  }\n\n  // Reset status\n  entity.status = {};\n  entity.actionPoints = entity.actionsPerTurn;\n\n  // Update prev position for each entity\n  entity.prevPosition = {\n    x: entity.position.x,\n    y: entity.position.y\n  };\n\n  // Perform any exisiting actions (likely just from player input)\n  performActions(entity.actions, entity, entities, newEvents);\n\n  // Clear any remaining existing actions for this turn\n  entity.actions = [];\n\n  // Perform any actions generated from behaviours\n  for (const behaviour of entity.behaviours) {\n    const actions = behaviour(entity, entities).reverse();\n    performActions(actions, entity, entities, newEvents);\n  }\n}\n\nexport const performTurns = (input, entities)=> {\n  const newEvents = {};\n  const player = findPlayer(entities);\n  const everythingElse = entities.filter(entity => entity.id !== player.id);\n\n  for (const entity of [player, ...everythingElse]) {\n    performTurn(entity, entities, newEvents);\n  }\n\n  // Remove anything that is dead\n  for (const entity of entities) {\n    if (entity.armour && entity.armour.defense <= 0) {\n      entity.armour = null;\n    }\n    if (entity.health <= 0) {\n      entity.alive = false;\n    }\n  }\n  const remainingEntities = entities.filter(entity => entity.alive);\n\n  totalTurns++;\n\n  return {\n    newEntities: remainingEntities,\n    newEvents\n  };\n}","import { findPlayer, findWeaponAt } from './entity/entity-util';\n\nconst keyToDirection = (key) => {\n  const mapping = {\n    ArrowUp: {x: 0, y: -1},\n    ArrowDown: {x: 0, y: 1},\n    ArrowLeft: {x: -1, y: 0},\n    ArrowRight: {x: 1, y: 0}\n  }\n\n  return mapping[key];\n}\n\nexport const getInput = key => {\n  const direction = keyToDirection(key);\n  if (direction) {\n    return {type: 'direction', direction } \n  };\n\n  if (key.toLowerCase() === 'x') {\n    return {type: 'primary'};\n  }\n\n  if (key.toLowerCase() === 'z') {\n    return {type: 'wait'};\n  }\n\n  if (key.toLowerCase() === 'r') {\n    return {type: 'restart'};\n  }\n\n  return {type: 'unknown'};\n}\n\nexport const processInput = (input, entities) => {\n  const player = findPlayer(entities);\n  const newActions = [];\n\n  if (input.type === 'direction') {\n    const action = {type: 'move', direction: input.direction, cost: 1};\n    newActions.push(action);\n  }\n\n  if (input.type === 'primary') {\n    const weapon = findWeaponAt(player.position, entities);\n    if (weapon) {\n      const action = {type: 'pick-up', entity: player, target: weapon, cost: 1}\n      newActions.push(action);\n    }\n    else {\n      const actions = player.weapon.use(player, entities);\n      newActions.push(...actions);\n    }\n  }\n\n  return newActions;\n}","import React, { useState, useEffect, useCallback } from 'react';\nimport { AppContainer, MapAndInfoContainer, MenuContainer } from './containers';\nimport Map from './map/Map';\nimport Info from './Info';\nimport WinGraphic from './WinGraphic';\nimport { generateLevel } from './map/map-generation';\nimport { player } from './entity/entities';\nimport { findPlayer, canEnterStairs } from './entity/entity-util';\nimport { performTurns } from './turn';\nimport { getInput, processInput } from './input';\nimport './App.css';\nimport './fonts/fonts.css';\n\nconst NUM_LEVELS = 5;\nconst MENU = 0;\n\nfunction App() {\n  const [level, setLevel] = useState(MENU);\n  const [entities, setEntities] = useState([]);\n  const [events, setEvents] = useState({});\n  const [hovered, setHovered] = useState({});\n  const lose = entities.length && !findPlayer(entities);\n  const win = level > NUM_LEVELS;\n\n  const hoverStart = (entity) => {\n    setHovered(entity);\n  }\n\n  const hoverStop = () => {\n    setHovered(null);\n  }\n\n  const startGame = () => {\n    setLevel(1);\n    setEntities(generateLevel(1, {...player({position: {x: 1, y: 1}})}));\n  }\n\n  const backToTitle = useCallback(() => {\n    setLevel(MENU);\n    setEntities([]);\n  }, []);\n\n  const nextLevel = useCallback(player => {\n    setLevel(level + 1);\n    if (level < NUM_LEVELS) {\n      setEntities(generateLevel(level + 1, player));\n    }\n  }, [level]);\n\n  const handleKeyDown = useCallback(event => {\n    const player = findPlayer(entities);\n    const { key } = event;\n    const input = getInput(key);\n\n    // prevent browser from scrolling up or down when used in an iframe on the itch.io page\n    if (input.type === 'direction') {\n      event.preventDefault();\n    }\n\n    if (level === MENU && input.type === 'primary') {\n      startGame();\n      return;\n    }\n\n    if ((win || lose) && input.type === 'primary') {\n      backToTitle();\n      return;\n    }\n\n    if (input.type === 'restart') {\n      startGame();\n      return;\n    }\n\n    if (input.type === 'primary' && canEnterStairs(player, entities)) {\n      nextLevel(player);\n      return;\n    }\n\n    if (!player) {\n      return;\n    }\n\n    if (input.type === 'direction' || input.type === 'wait' || input.type === 'primary') {\n      // generate player actions from the current input\n      const inputActions = processInput(input, entities);\n      player.actions.push(...inputActions);\n\n      // perform state changes based on entity behaviours and actions\n      const { newEntities, newEvents } = performTurns(input, entities);\n      setEntities(newEntities);\n      setEvents(newEvents);\n    }\n  }, [entities, nextLevel, backToTitle, level, lose, win]);\n\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleKeyDown]);\n\n  return (\n    <AppContainer win={win} lose={lose}>\n      {level === MENU ?\n        // Title screen\n        <MenuContainer>\n          <h1>bomblike</h1>\n          <button onClick={startGame}>play <span className={'key'}>(x)</span></button>\n        </MenuContainer>\n      :\n        // Main game screen\n        <MapAndInfoContainer\n          className={'map-container'}\n          shake={events.shake === true}\n        >\n          {win\n            ?\n              <WinGraphic />\n            :\n              <Map\n                entities={entities.filter(e => e.visible)}\n                hoverStart={hoverStart}\n                hoverEnd={hoverStop}\n              />}\n          <Info\n            entities={entities}\n            hovered={hovered}\n            win={win}\n            lose={lose}\n            events={events}\n          />\n        </MapAndInfoContainer>\n      }\n    </AppContainer>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));"],"sourceRoot":""}